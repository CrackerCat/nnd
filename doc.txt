(This is a low-quality information dump intended as both a plan for a demo/talk and a better-than-nothing documentation.)
(Note: "debuggee" is not a typo, it means the program that's being debugged.)

nnd is a debugger that has a TUI and is meant to be fast and enjoyable to use, and work well on large executables. (It stands for "no-nonsense debugger", but doesn't quite live up to this name at the moment.)

limitations:
  linux only
  x86 only
  64-bit only
  tui only
  no remote debugging (but works fine over ssh)
  single process (doesn't follow forks)
  no rr

properties:
  not based on gdb or lldb, implemented mostly from scratch (except a few things like disassembler, DWARF parser, and a TUI rendering library)
    many tricky things implemented manually: stepping (dealing with inlined functions), breakpoints (switching between hw/sw breakpoints), symbols handling (data structures, parallel loading), type system (parallel loading and dedup), watch expression interpreter, value tree in watches window, other custom ui widgets and behaviors
  fast
    things that can be instantaneous should be instantaneous
      i.e. snappy UI, no random freezes, no long waits
      (current known exceptions: function search is temporarily slow and blocking; if debuggee has >~2k threads things become pretty slow, can be improved; running over ssh adds latency)
    things that can't be instantaneous (symbols loading, function and type search) should be reasonably efficient, multi-threaded, asynchronous, cancellable, and have progress bars
  works on large executables (tested mostly on 2.5 GB clickhouse)
  reasonably careful error reporting

features:
  ways to run:
    run a program: `nnd executable [args...]`, i.e. just prepend `nnd` to the command line
      by default debuggee's stdout and stderr are redirected to ~/.nnd/<number>/{out,err}, and stdin is redirected to /dev/null
        --in <path> and --out <path> to change
      the program starts out paused, at a point right after exec - after dynamic libraries are loaded, but before main() or static variable constructors
    attach to process: `sudo nnd -p pid`
      (note that it then creates the `~/.nnd/<number>` directory in *root* user's home directory, not current user's)
  the UI consists of a few windows
    at any time, one window is active, indicated with bold bright outline
    ctrl-wasd to switch active window
    todo: resizing and rearranging windows
  hints window (top left) lists key bindings
    some keys are global, some depend on the selected window
    this should be enough to figure out most things by trial and error (instead of relying on this meager documentation)
  loading debug symbols
    progress bar in the binaries window, top right
    multithreaded, reasonably fast
    debugger is functional while symbols are loading, but there won't be line numbers or function names, etc
    after symbols are loaded, everything is automatically refreshed, so things like function names and source code appear
    supports DWARF 4 and 5, debuglink, compressed ELF sections
    memory usage is ~3x the size of the executable (e.g. ~8 GB for 2.3 GB clickhouse, release build)
  threads window (bottom right)
    color tells the stop reason
    search
      not fuzzy
      matches function name and file name
      todo: better search, negative filters (e.g. to filter out idle threads waiting for work or epoll), search by thread name, by line number
  stack trace window (right)
    when switching frame, jumps to the location in disassembly and source code
  source code window (bottom)
    looks for files relative to the working directory - you may need to `cd` to the code checkout before starting the debugger
    file search
      fuzzy
      only sees files mentioned in the debug symbols
    shows statements and inlined calls
    scrolls disassembly window when moving cursor
      can cycle through locations if multiple
      prioritizes locations close to disassembly window cursor
    breakpoints
    shows URL for rust standard library files
    todo: search, go-to-line
  stepping
    into-instruction, into-line, over-instruction, over-line, over-column (useful for function arguments), out
    aware of inlined functions
    frame-dependent (e.g. step-out steps out of the selected stack frame, not the top stack frame; similar for step-over)
    disables breakpoints for the duration of the step
    todo: handle exceptions/panics properly; currently if you step-over a function, and it throws an exception, the step will get stuck (interruptible with C-c)
  disassembly window (top)
    shows inlined functions
    scrolls source window when moving cursor
      can change inline depth
    function search
      fuzzy
      mangled :(
      shows file:line
      todo: by file, by address
    shows breakpoint locations (for breakpoints added in the source code window)
    todo: adding breakpoints (including on inlined call sites)
    todo: disassemble arbitrary memory (e.g. JIT-generated code, or binaries with no debug info or symtab, or during symbols loading)
  watches, locals, registers (bottom left)
    tree
    automatic downcasting of virtual classes to the most concrete type
    expression language
      a custom simple scripting language
      type system
        structs/classes/enums/unions/primitive-types/typedefs from the debuggee's debug symbols are available
        common primitive types are also always available by these names: void, u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, char8, char32, bool
        "* MyType" is pointer to MyType
        "[100] MyType" is array of 100 MyType-s
      can access debuggee's local variables (as seen in the locals window), registers, and script variables (see below)
      type cast: "p as *u8"
      field access: "my_struct.my_field"
        no "->" operator, use "." instead (it'll auto-dereference pointers)
        fields can also be accessed by index: "my_struct.3" (useful when field names are empty or duplicate)
      has basic C-like things you'd expect: arithmetic and logical operators, literals, array indexing, pointer arithmetic, "&x", "*x"
      inspecting types
        "type(<name>)" to get information about a type
          use backticks to escape names with templates or weird characters: "type(`std::__1::atomic<int>`)"
          the name must be fully-qualified
          requires exact name match, doesn't parse templates etc; e.g. `std::__1::atomic<int>` works (on some version of libc++), but `std::__1::atomic<int32_t>` and `std::atomic<int>` don't
            todo: type search
        "typeof(<expression>)" to get information about result type of an expression
          currently the expression is partially evaluated in some cases, e.g. "typeof(*(0 as *mystruct))" works, but "typeof((0 as *mystruct).myfield)" doesn't
          todo: support casting to typeof: "foo as typeof(bar)"
        e.g. "type(DB::Chunk).size" is an easy way to get sizeof for a struct; similar for field offsets
        todo: show declaration site
      script variables:
        "x=foo.bar.baz" to assign to a new script variable "x", which can then be used by later watch expressions
        can't assign to debuggee's variables, just hold values for use in other watches
        expressions are evaluated in order from top to bottom
        values are held by reference when possible, e.g. "&x" works after "x=foo.bar", but not after "x=1"
        no scopes, all script variables are global
        if debuggee has a variable by the same name, it can be accessed with backticks: "`x`", while the script variable can be accessed without backticks: "x"
      "value.#x" to show value in hexadecimal, "value.#b" in binary
        propagates to descendants, e.g. doing ".#x" on a struct makes all its field print in hex
      pretty-printers
        todo: pretty-printers for things like std::vector, std::string, std::shared_ptr, etc
        there are some general pretty-printers:
          if a struct has only one nonempty field, we unwrap it and show the field's value directly; e.g. unique_ptr turns into a plain pointer
          classes are automatically downcasted to the most concrete class
            this often fails if the base class is a template or is in anonymous namespace or anything else weird (I blame DWARF)
        "value.#r" disables pretty-printers
          works with field access too: "s.#r.f" will access direct field "f" of struct "s" (without unwrapping and downcasting)
      "p.[n]" to turn pointer "p" to array of length "n"
      "begin..end" to turn a pair of pointers to an array [begin, end)
    todo: global variables
  breakpoints (top right, second tab)
    aware of inlined functions
    can be disabled
    jump to location when selecting in the breakpoints window
    shows adjusted line
    todo: whole-file breakpoints, data breakpoints, conditional breakpoints, special breakpoints (signals, exceptions/panics, main()), auto-retry on dynamic library load
  autosaving/restoring state
    saves watches, breakpoints, source and disassembly tabs
    lives in ~/.nnd/<number>/state
    restored breakpoints are disabled on startup, enable them manually
  obscure feature: locations window
    for selected disassembly line
  secret feature: C-p for self-profiler
  secret feature: C-l to drop caches and redraw

tips and caveats:
  please report bugs, crashes, friction (UI inconvenience/unintuitiveness/jank), suggestions, slowness, missing critical features, etc, to #debugger in slack (if you're not in clickhouse, and this document reached you somehow, send reports to mk.al13n@gmail.com)
    there's a log file in ~/.nnd/<number>/log
  for clickhouse server, use CLICKHOUSE_WATCHDOG_ENABLE=0, otherwise it forks on startup, and the debugger doesn't follow forks
  if debugger is attached with -p, and some breakpoints are active, then the debugger segfaults or is killed, the breakpoints won't be deactivated, and the debuggee will get SIGTRAP and crash when hitting them
    but if the debugger exits normally or crashes with a panic (look at ~/.nnd/*/log for stack trace) then everything is fine and breakpoints are removed
  step-into-instruction (S key) works no matter what, even if there are no debug symbols or if disassembly or stack unwinding fails
  stepping can be interrupted with C-c; e.g. if you try to step-over a function, but the function turns out to be too slow
  rust unions are not supported well: they show discriminator and all variants as fields, with no indication of which discriminator values correspond to which variants; but it's mostly usable
  code and disassembly windows have horizontal scrolling; all other places in the UI cut off long strings with no way to see the whole thing; this is particularly annoying for error messages in watches window
    workaround for stack trace: the full function/file name for the selected stack frame can be seen in disassembly window (which also has horizontal scrolling)
  to debug interactive programs (i.e. requiring a tty, e.g. for TUI, e.g. using nnd to debug itself), just attach using -p
    but what if you need to set breakpoints before the program starts, e.g. to debug a crash on startup? then you can do this:
      1. Open a terminal window (in xterm or tmux or whatever). Let's call this window A. This is where you'll be able interact with the debuggee.
      2. This terminal window is attached to some "pty" "device" in /dev/pts/ . Figure out which one:
           $ ls -l /proc/$$/fd | grep /dev/pts/
         For example, suppose it output /dev/pts/2 . You can also double-check this with: `echo henlo > /dev/pts/2` - if the text appears in the correct terminal then it's the correct path.
      3. Pacify the shell in this terminal window:
           $ sleep 1000000000
      4. In another terminal window (B) run the debugger:
           $ nnd --in /dev/pts/2 --out /dev/pts/2 the_program_to_debug
      5. Now you have the debugger running in window B while the debuggee inhabits the terminal in window A
         (which will come to life when you resume the debuggee in the debugger, `sleep` notwithstanding).

big todos:
  playtesting
  be less slow when the debuggee lots of threads
  automated tests
  manual testing on more programs (it's only tested on clickhouse, itself, and a few tiny test programs)
  pretty-printers
    maybe written in the watch expression language, after extending/redesigning it sufficiently for that
  general UI improvements (rewrite tui-rs):
    line wrapping or horizontal scrolling everywhere: stack, threads, watches, breakpoints, tabs
    scroll bars
      and some indication of horizontal scrolling
    fix colors in source window on horizontal scrolling
    fix handling unicode character width in a few places
    text editing: selection, copy-paste
    no double-borders around windows
    general prettification
    take styles from palette instead of hard-coding them everywhere
  some kind of remote debugging, to cover the case when a stripped executable is running on remote production server, while the source code and unstripped executable are available locally
    until then, you can scp the code (just the parts you need) to the server, switch it to unstripped executable, and run the debugger over ssh; too much friction
